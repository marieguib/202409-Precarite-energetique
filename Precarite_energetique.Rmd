---
title: "Quelles seront les sollicitations de subventions pour le fonds verts des communes en Bretagne ? Et pourquoi ?"
author: "Marie Guibert"
date: "2024-03-05"
output:
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
---

# Environnement de travail


```{r message = FALSE}
library(aws.s3)
library(dplyr)
library(stringr)
```

# I. Importations et traitements des données

Tout d'abord, nous allons nous focaliser sur la région Bretagne dans un premier temps lors de cette étude. 

## I.1. Variable à expliquer

On importe d'abord les données CHORUS concernant le programme 380 (fonds vert) pour récupérer les informations nécessaires à notre étude. 

```{r message = FALSE}
BUCKET <- "marieguibert2"
FILE_KEY_S3 <- "Sujet_master/Data/Y/sqllab_untitled_query_1_20240405T134355.csv"

ae_fonds_vert <- 
  aws.s3::s3read_using(
    FUN = readr::read_csv, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

ae_fonds_vert$beneficiaire_code <- as.character(ae_fonds_vert$beneficiaire_code)

head(ae_fonds_vert)
```

```{r}
dim(ae_fonds_vert)
```

Nous avons 232 bénéficiaires et 68 colonnes. Pour continuer notre analyse nous allons sélectionner les données au niveau communal 


```{r}
# Vérification que tous les SIRET fassent bien 14 caractères
table(str_length(ae_fonds_vert$beneficiaire_code))
```

```{r}
# Vérification qu'on ait que des communes
table(ae_fonds_vert$denomination)
```


```{r}
# Vérification que toutes les données soient sur 2023
table(ae_fonds_vert$annee)
```

Ce tableau nous montre que le programme du fonds vert ne contient des données seulement pour l'année 2023. Nous allons nous intéresser au code INSEE de la commune du SIRET et le montant du financement. 

```{r}
ae_fonds_vert_montant <- ae_fonds_vert %>% 
  select(code_commune, montant_ae) %>% 
  group_by(code_commune) %>% 
  summarize(somme_ae = sum(montant_ae))

head(ae_fonds_vert_montant)
```

```{r}
dim(ae_fonds_vert_montant)
```

Nous allons grouper par commune du SIRET pour avoir une approche communale et pour savoir le nombre de projets par commune.

```{r}
ae_fonds_vert_nb <- ae_fonds_vert %>%
  group_by(code_commune) %>%
  summarize(nb_projets = n())

head(ae_fonds_vert_nb)
```
```{r}
table(ae_fonds_vert_nb$nb_projets)
```

Puisque nous avons une grande majorité de communes demandant un seul financement, nous allons passer notre variable en binaire : "a demandé un financement / n'a pas demandé de financement"
- Valeur 1 : a demandé un financement
- Valeur 0 : n'a pas demandé de financement

```{r}
ae_fonds_vert_binaire <- ae_fonds_vert %>%
  select(code_commune) %>% 
  group_by(code_commune) %>%
  summarize(beneficiaire = 1)


# Conversion pour avoir les mêmes types que dans le fichier communes
ae_fonds_vert_binaire$code_commune <- as.character(ae_fonds_vert_binaire$code_commune)
```

Notre tableau final contient bien le code de la commune du SIRET et si la commune a demandé un financement (1)

Pour pouvoir constituer notre variable à expliquer, il nous faut le reste des communes de Bretagne pour pouvoir savoir quelles communes n'ont pas fait de demande de financement

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/Y/commune2021.csv"

communes <- 
  aws.s3::s3read_using(
    FUN = read.csv, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(communes)
```


On filtre d'abord sur la Bretagne pour n'avoir que les communes qui nous intéressent.

```{r}
communes <- communes %>% 
  select(COM, REG) %>% 
  filter(REG == 53) %>% 
  select(COM)
```

On ajoute une colonne avec la valeur 0

```{r}
communes <- communes %>% 
  mutate(beneficiaire = 0) %>% 
  rename(code_commune = COM)
```

Nous allons maintenant assembler les deux fichiers pour avoir notre variable à expliquer complète.


Règle : si un code INSEE d'une commune apparaît avec la valeur 0 ET la valeur 1 alors on garde seulement la ligne avec la valeur 1 => cela signifie qu'elle a fait une demande de financement


```{r}
beneficiaires_fonds_vert <- merge(ae_fonds_vert_binaire, communes, 
                                  by = "code_commune", 
                                  all = TRUE, suffix = c("_ae", "_com"))

# Remplacer les valeurs NA par 0
beneficiaires_fonds_vert$beneficiaire <- ifelse(is.na(beneficiaires_fonds_vert$beneficiaire_ae), 0, 1)

beneficiaires_fonds_vert <- beneficiaires_fonds_vert %>% 
  select(code_commune, beneficiaire) %>% 
  rename(beneficiaire_prog = beneficiaire)

head(beneficiaires_fonds_vert)
```

```{r}
dim(beneficiaires_fonds_vert)
```

Nous avons bien 1208 communes (nombre de communes en Bretagne)

Nous allons analyser la distribution des 1 et 0 dans notre variable à expliquer

```{r}
ggplot(beneficiaires_fonds_vert)+
  aes(x = beneficiaire_prog)+
  geom_bar(fill="lightblue")+
  ggtitle("Nombre de communes ayant demandé un financement pour le programme 380")
```
```{r}
table(beneficiaires_fonds_vert$beneficiaire)
```

Nous avons donc des données déséquilibrées à traiter de ce cas là.


## I.2. Variables explicatives

Nous allons à présent passer à l'importation des différentes variables explicatives. 


### I.2.A. Energie

Nous allons importer les données de consommation annuelle d'électricité et de gaz

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/conso-elec-gaz-annuelle-par-secteur-dactivite-agregee-commune.csv"

conso_elec_gaz <- 
  aws.s3::s3read_using(
    FUN = read.csv, 
    sep = ";",
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

Nous allons ensuite filtrer pour n'avoir que les lignes concernant la Bretagne

```{r}
conso_elec_gaz <- conso_elec_gaz %>% 
  filter(Code.Région == 53) %>% 
  filter(Opérateur == "Enedis")
```

Ensuite, nous allons faire la moyenne pour n'avoir qu'un seul chiffre par commune

```{r}
conso_agriculture <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`,`Consommation.Agriculture..MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_agri = mean(`Consommation.Agriculture..MWh.`))
```

```{r}
conso_industrie <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.Industrie..MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_indus = mean(`Consommation.Industrie..MWh.`))
```

```{r}
conso_tertiaire <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`,`Consommation.Tertiaire...MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_tertiaire = mean(`Consommation.Tertiaire...MWh.`))
```

```{r}
conso_residentiel <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.Résidentiel...MWh.`)%>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_residentiel = mean(`Consommation.Résidentiel...MWh.`))
```

```{r}
conso_totale <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.totale..MWh.`)%>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_totale = mean(`Consommation.totale..MWh.`))
```

Nous avons bien le bon nombre de lignes pour chaque variable. Nous allons vérifier s'il y a des valeurs manquantes

```{r}
sum(is.na(conso_agriculture))
sum(is.na(conso_industrie))
sum(is.na(conso_residentiel))
sum(is.na(conso_tertiaire))
sum(is.na(conso_totale))
```

Nous n'avons pas de données manquantes donc on peut continuer l'étude

### I.2.B. Logement

Nous allons importer des données concernant la thématique du logement

Tout d'abord, nous allons nous focaliser sur le DPE des logements. Le Diagnostic de Performance Energétique (DPE) renseigne sur la performance énergétique et environnementale d’un logement ou d’un bâtiment, en évaluant sa consommation d’énergie et son impact en matière d’émissions de gaz à effet de serre.


```{r}

```



Nous allons maintenant nous intéresser à la base de données "cartofriches". Elle permet de référencer des sites potentiellement en friche. Le terme de « friches » est pris ici dans le sens d’espaces artificialisés et inoccupés.

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Logement/friches-standard.csv"

fichier_friches <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

possede_friches <- fichier_friches %>% 
  select(comm_insee) %>% 
  group_by(comm_insee) %>% 
  summarize(nb_friches = n())
  
  
head(possede_friches)
```
Pour avoir le reste des communes de la France, nous allons ajouter des 0 sur les lignes où on a pas de valeur

```{r}
friches <- merge(possede_friches, communes, 
                                  by.x = "comm_insee", by.y = "code_commune",
                                  all = TRUE, suffix = c("_friche", "_com"))

# On ne garde que les communes en Bretagne
friches <- friches %>%
  filter(substr(comm_insee, 1, 2) %in% c("22", "29", "35", "56")) 

# Si le nombre de friches est NA alors on remplace par 0
friches$friche <- ifelse(is.na(friches$nb_friches), 0, 1)

friches <- friches %>% 
  select(comm_insee, friche)

head(friches)
```


La démarche ÉcoQuartier, portée par le Ministère de la Transition écologique et de la Cohésion des Territoires, favorise de nouvelles façons de concevoir, construire et gérer la ville durablement. 
Cette variable m'a donc paru importante à inclure dans le programme du fonds vert. 

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Logement/EcoQuartiers_jan2016.csv"

eco_quartiers <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(eco_quartiers)  
```

On conserve seulement la colonnes qui nous intéresse pour notre étude : le code INSEE. On considère que si la commune apparaît, alors elle porte / fait partie d'un projet d'écoquartiers. 

```{r}
eco_quartiers <- eco_quartiers %>% 
  select(`Code INSEE`) %>% 
  group_by(`Code INSEE`) %>% 
  mutate(ecoquartiers= n())

head(eco_quartiers)
```

Nous allons ajouter les communes ne présentant pas d'écoquartiers 

```{r}
communes_eco_quartiers <- merge(eco_quartiers, communes, 
                                  by.x = "Code INSEE", by.y = "code_commune", 
                                  all = TRUE, suffix = c("_ecoquartiers", "_com"))

# Remplacer les valeurs NA par 0
communes_eco_quartiers$beneficiaire <- ifelse(is.na(communes_eco_quartiers$ecoquartiers), 0, 1)

communes_eco_quartiers <- communes_eco_quartiers %>% 
  select(`Code INSEE`, beneficiaire) %>% 
  rename(ecoquartiers = beneficiaire)

head(communes_eco_quartiers)
```
On ne conserve que les communes de Bretagne

```{r}
communes_eco_quartiers <- communes_eco_quartiers %>% 
  filter(substr(`Code INSEE`, 1, 2) %in% c("22", "29", "35", "56")) 
```

On va supprimer les doublons : on considère cette variable comme une variable binaire donc on ne comptabilise pas le nombre d'éco-quartiers

```{r}
communes_eco_quartiers <- distinct(communes_eco_quartiers)
```

### I.2.C. Urbanisme

Nous allons importer le fichier qui recense les villages d'avenir (communes qui sont bénéficiaires d'un programme : PVD, ACV, ...)

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/zonages.xlsx"

zonages_prog <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(zonages_prog)
```

On conserve les colonnes avec le code de la commune et si elle est bénéficiaire ou non d'un programme (ACV / PVD / ...)

```{r}
zonages_prog <- zonages_prog %>% 
  select(1,3) %>% 
  rename("beneficiaire_prog" = va_zpp) %>% 
  mutate(beneficiaire_prog = gsub("out", "0", beneficiaire_prog)) %>%
  mutate(beneficiaire_prog = gsub("in", "1", beneficiaire_prog))

head(zonages_prog)
```

On conserve les communes de Bretagne

```{r}
zonages_prog <- zonages_prog %>% 
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

On ajoute la commune manquante au document

```{r}
zonages_prog <- merge(zonages_prog, communes, 
                                  by.x = "codgeo",  by.y = "code_commune", 
                                  all = TRUE, suffix = c("_ae", "_com"))

# Remplacer les valeurs NA par 0
zonages_prog$beneficiaire_prog_zonages <- ifelse(is.na(zonages_prog$beneficiaire_prog), NA, 1)

zonages_prog <- zonages_prog %>% 
  select(codgeo, beneficiaire_prog_zonages)

head(zonages_prog)
```

On importe ensuite les données concernant les communes couvertes par les CRTE 

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/liste-crte-com2023-20230823.csv"

liste_crte <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(liste_crte)
```

On ne conserve seulement que la colonne avec le code commune et on ajoute une colonne avec la valeur 1 pour signifier qu'elles sont couvertes par les CRTE (variable binaire)

```{r}
liste_crte <- liste_crte %>% 
  select(1) %>% 
  group_by(insee_com) %>% 
  mutate("couverte_crte" = 1)

head(liste_crte)
```

Nous allons seulement conserver les communes de Bretagne

```{r}
liste_crte <- liste_crte %>% 
  filter(substr(insee_com, 1, 2) %in% c("22", "29", "35", "56")) 
```

Nous avons deux communes manquantes que nous allons ajouter

```{r}
communes_crte <- merge(liste_crte, communes, 
                                  by.x = "insee_com",  by.y = "code_commune", 
                                  all = TRUE, suffix = c("_crte", "_com"))

# Remplacer les valeurs NA par 0
communes_crte$couverte_crte <- ifelse(is.na(communes_crte$couverte_crte), NA, 1)

communes_crte <- communes_crte %>% 
  select(insee_com, couverte_crte)

head(communes_crte)
```


Nous allons à présent importer les données pour savoir si la commune est concernée par la loi littoral (COG de 2022)

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/loi_littoral-1996-COG2022.xlsx"

loi_littoral <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    sheet = "Perimetre",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(loi_littoral)
```

On conserve le code insee de la commune et le classement. On va ensuite convertir la variable classement en une variable à plusieurs modalités

```{r}
loi_littoral <- loi_littoral %>% 
  select(INSEE_COM, CLASSEMENT)

head(loi_littoral)
```

On transforme ensuite la variable CLASSEMENT en une variable à 3 modalités

```{r}
table(loi_littoral$CLASSEMENT)
```

```{r}
loi_littoral <- loi_littoral %>% 
  mutate(CLASSEMENT = gsub("Estuaire", "0", CLASSEMENT)) %>%
  mutate(CLASSEMENT = gsub("Lac", "1", CLASSEMENT)) %>% 
  mutate(CLASSEMENT = gsub("Mer", "2", CLASSEMENT))

table(loi_littoral$CLASSEMENT)
```

```{r}
head(loi_littoral)
```

Nous allons conserver les communes de Bretagne

```{r}
loi_littoral <- loi_littoral %>% 
  filter(substr(INSEE_COM, 1, 2) %in% c("22", "29", "35", "56")) 

dim(loi_littoral)
```

On remarque que nous avons seulement 264 communes de Bretagne, nous allons donc devoir compléter par des valeurs manquantes

```{r}
loi_littoral <- merge(loi_littoral, communes, 
                                  by.x = "INSEE_COM", by.y = "code_commune", 
                                  all = TRUE, suffix = c("_littoral", "_com"))

# Remplacer les valeurs NA par 0
loi_littoral$climat <- ifelse(is.na(loi_littoral$CLASSEMENT), NA, 1)

loi_littoral <- loi_littoral %>% 
  select(INSEE_COM, climat) 

head(loi_littoral)
```


Nous allons ensuite importer les données qui décrivent la grille communale de densité en 7 niveaux : 
- niveau 1 : Grands centres urbains
- niveau 2 : Centres urbains intermédiaires
- niveau 3 : Petites villes
- niveau 4 : Ceintures urbaines
- niveau 5 : Bourgs ruraux
- niveau 6 : Rural à habitat dispersé
- niveau 7 : Rural à habitat très dispersé

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/densite_7niveaux.xlsx"

densite7 <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    sheet = 'Data',
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(densite7)
```

On conserve le code et la grille de niveaux

```{r}
densite7 <- densite7 %>% 
  select(1,3)

head(densite7)
```

Nous allons conserver seulement les communes de Bretagne

```{r}
densite7 <- densite7 %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

Il nous manque une commune que nous allons ajouter

```{r}
densite7 <- merge(densite7, communes, 
                                  by.x = "codgeo", by.y = "code_commune",
                                  all = TRUE, suffix = c("_friche", "_com"))

# On ne garde que les communes en Bretagne
densite7 <- densite7 %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 

# Si le nombre de friches est NA alors on remplace par 0
densite7$gridens7 <- ifelse(is.na(densite7$gridens7), 0, 1)

densite7 <- densite7 %>% 
  select(codgeo, gridens7)

head(densite7)
```

Nous allons ensuite importer les données concernant la superficie de chaque commune

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/superficie.xlsx"

superficie <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    sheet = 'Data',
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(superficie)
```


Nous allons conserver les superficies les plus actualisées (pour l'année 2020) et sélectionner les colonnes qui nous intéressent

```{r}
superficie <- superficie %>% 
  filter(an == 2020) %>% 
  select(codgeo, superf_choro)

head(superficie)
```

Nous allons sélectionner les données pour les communes de Bretagne

```{r}
superficie <- superficie %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56"))
```

Nous ajoutons la commune manquante


```{r}
superficie <- merge(superficie, communes, 
                                  by.x = "codgeo", by.y = "code_commune",
                                  all = TRUE, suffix = c("_superficie", "_com"))

# On ne garde que les communes en Bretagne
superficie <- superficie %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 

# Si la superficie est NA alors on remplace par NA
superficie$superf_choro <- ifelse(is.na(superficie$superf_choro), NA, 1)

superficie <- superficie %>% 
  select(codgeo, superf_choro)

head(superficie)
```

### I.2.D. Transport

Nous allons maintenant importer des données concernant la thématique du transport.

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Transport/arret_ferroviaire.csv"

gares <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(gares)
```

On conserve les colonnes qui peuvent nous être utiles par la suite

```{r}
gares <- gares %>% 
  select(code_uic,code_insee, tgv)
head(gares)
```

On modifie la variable pour avoir une variable binaire

```{r}
gares <- gares %>%  
  mutate(tgv = gsub("O", "1", tgv)) %>%
  mutate(tgv = gsub("N", "0", tgv)) 
```

Il faut supprimer les doublons => garder O si O et N sinon 0

```{r}
length(unique(gares$code_insee))
```


### I.2.E. Population / Economie / Emploi


```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/mediane_revenu_dispo.xlsx"

revenu_dispo <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(revenu_dispo)
```

On sélectionne les variables qui nous intéresse pour la suite

```{r}
revenu_dispo <- revenu_dispo %>% 
  select(codgeo, med_disp)
```

Nous allons maintenant importer les données de population

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/population.xlsx"

pop <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(pop)
```


```{r}
pop <- pop %>% 
  filter(an == 2020) %>% 
  select(codgeo, p_pop)

head(pop)
```

Nous allons maintenant importer des données un peu plus sensibles : les maires en 2023

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/elus-municipaux-cm.csv"

elus <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(elus)
```



# II. Visualisation des données


```{r}
library(ggplot2)
ggplot(superficie)+
  aes(x = 1:34945, y = superf_choro)+
  geom_point()
```



# III. Modélisation statistique


## Apprentissage supervisé

## Apprentissage non-supervisé


# IV. Résultats
