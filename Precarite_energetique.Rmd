---
title: "Quelles seront les sollicitations de subventions pour le fonds verts des communes en Bretagne ? Et pourquoi ?"
author: "Marie Guibert"
date: "2024-03-05"
output:
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
---

# Environnement de travail


```{r message = FALSE, warning = FALSE}
library(aws.s3)
library(dplyr)
library(stringr)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(httr)
library(jsonlite)


library(corrplot)
```

# I. Importations et traitements des données

Tout d'abord, nous allons nous focaliser sur la région Bretagne dans un premier temps lors de cette étude. 

## I.1. Variable à expliquer

On importe d'abord les données CHORUS concernant le programme 380 (fonds vert) et les données de l'ADEME au niveau communal pour récupérer les informations nécessaires à notre étude. Ces deux programmes concernent la transition écologique c'est pourquoi ils ont été choisis.

```{r message = FALSE}
BUCKET <- "marieguibert2"
FILE_KEY_S3 <- "Sujet_master/Data/Y/prog380ademe_communes.csv"

ae_transition_eco <- 
  aws.s3::s3read_using(
    FUN = readr::read_csv, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

ae_transition_eco$beneficiaire_code <- as.character(ae_transition_eco$beneficiaire_code)

head(ae_transition_eco)
```

On ne récupère les données que pour l'année 2023

```{r}
ae_transition_eco <- ae_transition_eco %>% 
  filter(annee == "2023") %>% 
  filter(substr(code_commune, 1, 2) %in% c("22", "29", "35", "56"))
```

```{r}
dim(ae_transition_eco)
```

Nous avons 460 lignes dans notre dataframe et 68 colonnes. 
Nous allons vérifier que nos données ne contiennent bien que des communes :

```{r include=FALSE}
# Vérification qu'on ait que des communes
table(ae_transition_eco$denomination)
```

```{r}
# Vérification que toutes les données soient sur 2023
table(ae_transition_eco$annee)
```

Ce tableau nous montre que le programme du fonds vert ne contient des données seulement pour l'année 2023. 

### Montant des AE

Nous allons nous intéresser au code INSEE de la commune du SIRET et le montant du financement. 

*Ici, le "code_commune" correspond à la commune du SIRET (jointure réalisée précédemment dans SQL Lab)*

```{r}
ae_transition_eco_montant <- ae_transition_eco %>% 
  select(code_commune, montant_ae) %>% 
  group_by(code_commune) %>% 
  summarize(somme_ae = sum(montant_ae))

head(ae_transition_eco_montant)
```

### Demandes de financements

Nous allons grouper par **commune du SIRET** pour avoir une approche communale et pour savoir le nombre de projets par commune.

```{r}
ae_transition_eco_nb <- ae_transition_eco %>%
  group_by(code_commune) %>%
  summarize(nb_projets = n())

head(ae_transition_eco_nb)
```

```{r}
table(ae_transition_eco_nb$nb_projets)
```

Puisque nous avons une grande majorité de communes demandant un seul financement, nous allons passer notre variable en binaire : "a demandé un financement / n'a pas demandé de financement".
- Valeur 1 : a demandé un financement
- Valeur 0 : n'a pas demandé de financement

Cette manipulation va nous simplifier le travail

```{r}
ae_transition_eco_binaire <- ae_transition_eco %>%
  select(code_commune) %>% 
  group_by(code_commune) %>%
  summarize(beneficiaire_trans_eco = 1)


# Conversion pour avoir les mêmes types que dans le fichier communes
ae_transition_eco_binaire$code_commune <- as.character(ae_transition_eco_binaire$code_commune)

head(ae_transition_eco_binaire)
```

Notre tableau final contient bien le code de la commune du SIRET et si la commune a demandé un financement concernant un programme de transition écologique (1)

### Fichier des communes

Pour pouvoir constituer notre variable à expliquer, il nous faut le reste des communes de Bretagne pour pouvoir savoir quelles communes n'ont pas fait de demande de financement

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/Y/v_commune_2023.csv"

communes <- 
  aws.s3::s3read_using(
    FUN = read.csv, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(communes)
```


On filtre d'abord sur la Bretagne pour n'avoir que les communes qui nous intéressent.

```{r}
communes <- communes %>% 
  select(COM, REG) %>% 
  filter(REG == 53) %>% 
  select(COM)
```

On ajoute une colonne avec la valeur 0

```{r}
communes <- communes %>% 
  mutate(beneficiaire_trans_eco = 0) %>% 
  rename(code_commune = COM)
```

Nous allons maintenant assembler les deux fichiers pour avoir notre variable à expliquer complète.

### Constitution de la variable à expliquer (binaire)

Règle : si un code INSEE d'une commune apparaît avec la valeur 0 ET la valeur 1 alors on garde seulement la ligne avec la valeur 1 => cela signifie qu'elle a fait une demande de financement


```{r}
# Fusionner les deux dataframes
beneficiaires_prog_trans_eco <- merge(ae_transition_eco_binaire, communes, all = T,
                                      by = "code_commune",suffix = c("_ae", "_com"))

# Remplacer les valeurs NA par 0 dans la colonne beneficiaire_trans_eco_ae
beneficiaires_prog_trans_eco$beneficiaire_trans_eco <- ifelse(is.na(beneficiaires_prog_trans_eco$beneficiaire_trans_eco_ae), 
                                                              0, beneficiaires_prog_trans_eco$beneficiaire_trans_eco_ae)

# Supprimer les colonnes inutiles
beneficiaires_prog_trans_eco <- beneficiaires_prog_trans_eco %>%
  select(code_commune, beneficiaire_trans_eco)

head(beneficiaires_prog_trans_eco)
```

```{r}
dim(beneficiaires_prog_trans_eco)
```

Nous avons bien 1207 communes (nombre de communes en Bretagne)

```{r}
# Renommage de la colonne pour le code commune en code INSEE
beneficiaires_prog_trans_eco <- beneficiaires_prog_trans_eco %>% 
  rename(code_insee = code_commune)
```

### Distribution de notre variable à explqiuer

Nous allons analyser la distribution des 1 et 0 dans notre variable à expliquer

```{r}
ggplot(beneficiaires_prog_trans_eco)+
  aes(x = beneficiaire_trans_eco)+
  geom_bar(fill="lightblue")+
  ggtitle("Nombre de communes ayant demandé un financement pour un\nprogramme financier favorisant la transition écologique")
```
```{r}
table(beneficiaires_prog_trans_eco$beneficiaire_trans_eco)
```

Nous avons donc des données déséquilibrées à traiter de ce cas là.


```{r}
# Suppression des variables inutiles
rm(ae_transition_eco)
rm(ae_transition_eco_binaire)
rm(ae_transition_eco_montant)
rm(ae_transition_eco_nb)
```

## I.2. Variables explicatives

Nous allons à présent passer à l'importation des différentes variables explicatives. 


### I.2.A. Energie

#### a) Consommation électricité / gaz

Nous allons importer les données de consommation annuelle d'électricité et de gaz

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Energie/conso-elec-gaz-annuelle-par-secteur-dactivite-agregee-commune.csv"

conso_elec_gaz <- 
  aws.s3::s3read_using(
    FUN = read.csv, 
    sep = ";",
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

Nous allons ensuite filtrer pour n'avoir que les lignes concernant la Bretagne

```{r}
conso_elec_gaz <- conso_elec_gaz %>% 
  filter(Code.Région == 53) %>% 
  filter(Opérateur == "Enedis")
```

Ensuite, nous allons faire la moyenne pour n'avoir qu'un seul chiffre par commune

```{r}
conso_agriculture <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`,`Consommation.Agriculture..MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_agri = mean(`Consommation.Agriculture..MWh.`))

conso_agriculture <- conso_agriculture %>% 
  rename(code_insee = Code.Commune)

head(conso_agriculture)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_agriculture <- merge(communes, conso_agriculture, by.x = "code_commune", by.y = "code_insee")

conso_agriculture <- conso_agriculture %>% 
  rename(code_insee = code_commune)

conso_agriculture <- conso_agriculture %>% 
  select(1,3)
```

```{r}
conso_industrie <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.Industrie..MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_indus = mean(`Consommation.Industrie..MWh.`))

conso_industrie <- conso_industrie %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_industrie <- merge(communes, conso_industrie, by.x = "code_commune", by.y = "code_insee")

conso_industrie <- conso_industrie %>% 
  rename(code_insee = code_commune)

conso_industrie <- conso_industrie %>% 
  select(1,3)
```

```{r}
conso_tertiaire <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`,`Consommation.Tertiaire...MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_tertiaire = mean(`Consommation.Tertiaire...MWh.`))

conso_tertiaire <- conso_tertiaire %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_tertiaire <- merge(communes, conso_tertiaire, by.x = "code_commune", by.y = "code_insee")

conso_tertiaire <- conso_tertiaire %>% 
  rename(code_insee = code_commune)

conso_tertiaire <- conso_tertiaire %>% 
  select(1,3)
```

```{r}
conso_residentiel <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.Résidentiel...MWh.`)%>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_residentiel = mean(`Consommation.Résidentiel...MWh.`))

conso_residentiel <- conso_residentiel %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_residentiel <- merge(communes, conso_residentiel, by.x = "code_commune", by.y = "code_insee")

conso_residentiel <- conso_residentiel %>% 
  rename(code_insee = code_commune)

conso_residentiel <- conso_residentiel %>% 
  select(1,3)
```

```{r}
conso_totale <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.totale..MWh.`)%>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_totale = mean(`Consommation.totale..MWh.`))


conso_totale <- conso_totale %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_totale <- merge(communes, conso_totale, by.x = "code_commune", by.y = "code_insee")

conso_totale <- conso_totale %>% 
  rename(code_insee = code_commune)

conso_totale <- conso_totale %>% 
  select(1,3)
```

Nous allons vérifier s'il y a des valeurs manquantes

```{r}
sum(is.na(conso_agriculture))
sum(is.na(conso_industrie))
sum(is.na(conso_residentiel))
sum(is.na(conso_tertiaire))
sum(is.na(conso_totale))
```

Nous n'avons pas de données manquantes


```{r}
# On supprime la variable qui ne nous sert pas 
rm(conso_elec_gaz)
```

#### b) Emissions GES

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Energie/emissions_ges.csv"

emissions_ges <- 
  aws.s3::s3read_using(
    FUN = read.csv, 
    sep = ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r}
emissions_ges <- emissions_ges %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "emissions_ges" = "Emissions.de.gaz.à.effet.de.serre.hors.puits..PRG...par.secteur.2021") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))

head(emissions_ges)
```

#### c) Conseil France Rénov'

```{r}
url_api <-  "https://data.ademe.fr/data-fair/api/v1/datasets/sare_tbs/values_agg?field=COMMUNE&metric=sum&metric_field=nb_actes&q=Bretagne&q_fields=REGION"


response <- GET(url_api)
response <- fromJSON(rawToChar(response$content), flatten = TRUE)
response <- as.data.frame(response)

france_renov <- response %>% 
  select(aggs.value, aggs.metric) %>% 
  rename("nb_actes_renov" = aggs.metric,
         "Commune"= aggs.value)

head(france_renov)
```


### I.2.B. Logement

Nous allons importer des données concernant la thématique du logement

#### a) DPE

Tout d'abord, nous allons nous focaliser sur le DPE des logements. Le Diagnostic de Performance Energétique (DPE) renseigne sur la performance énergétique et environnementale d’un logement ou d’un bâtiment, en évaluant sa consommation d’énergie et son impact en matière d’émissions de gaz à effet de serre.


```{r}

```

#### b) Friches

Nous allons maintenant nous intéresser à la base de données "cartofriches". Elle permet de référencer des sites potentiellement en friche. Le terme de « friches » est pris ici dans le sens d’espaces artificialisés et inoccupés.

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Logement/friches-standard.csv"

friches <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

friches <- friches %>% 
  select(comm_insee) %>% 
  group_by(comm_insee) %>% 
  summarize(nb_friches = n())
  
  
head(friches)
```
Pour avoir le reste des communes de la France, nous allons ajouter des 0 sur les lignes où on a pas de valeur

```{r}
friches <- merge(friches, communes, 
                                  by.x = "comm_insee", by.y = "code_commune",
                                  all = TRUE, suffix = c("_friche", "_com"))

# On ne garde que les communes en Bretagne
friches <- friches %>%
  filter(substr(comm_insee, 1, 2) %in% c("22", "29", "35", "56")) 

# Si le nombre de friches est NA alors on remplace par 0
friches$friche <- ifelse(is.na(friches$nb_friches), 0, friches$nb_friches)

friches <- friches %>% 
  select(comm_insee, friche)

head(friches)
```

```{r}
# Renommage de la colonne pour le code insee
friches <- friches %>% 
  rename(code_insee = comm_insee)
```

#### c) Ecoquartiers

La démarche ÉcoQuartier, portée par le Ministère de la Transition écologique et de la Cohésion des Territoires, favorise de nouvelles façons de concevoir, construire et gérer la ville durablement. 
Cette variable m'a donc paru importante à inclure dans le programme du fonds vert. 

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Logement/EcoQuartiers_jan2016.csv"

eco_quartiers <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(eco_quartiers)  
```

On conserve seulement la colonnes qui nous intéresse pour notre étude : le code INSEE. On considère que si la commune apparaît, alors elle porte / fait partie d'un projet d'écoquartiers. 

```{r}
eco_quartiers <- eco_quartiers %>% 
  select(`Code INSEE`) %>% 
  group_by(`Code INSEE`) %>% 
  mutate(ecoquartiers= n())

head(eco_quartiers)
```

Nous allons ajouter les communes ne présentant pas d'écoquartiers 

```{r}
communes_eco_quartiers <- merge(eco_quartiers, communes, 
                                  by.x = "Code INSEE", by.y = "code_commune", 
                                  all.y = TRUE, suffix = c("_ecoquartiers", "_com"))

# Remplacer les valeurs NA par 0
communes_eco_quartiers$beneficiaire <- ifelse(is.na(communes_eco_quartiers$ecoquartiers), 0, 1)

communes_eco_quartiers <- communes_eco_quartiers %>% 
  select(`Code INSEE`, beneficiaire) %>% 
  rename(ecoquartiers = beneficiaire)

head(communes_eco_quartiers)
```

On ne conserve que les communes de Bretagne

```{r}
communes_eco_quartiers <- communes_eco_quartiers %>% 
  filter(substr(`Code INSEE`, 1, 2) %in% c("22", "29", "35", "56")) 
```

On va supprimer les doublons : on considère cette variable comme une variable binaire donc on ne comptabilise pas le nombre d'éco-quartiers

```{r}
communes_eco_quartiers <- distinct(communes_eco_quartiers)
```

```{r}
communes_eco_quartiers <- communes_eco_quartiers %>% 
  rename(code_insee = `Code INSEE`)
```

```{r}
# Suppression variables inutiles
rm(eco_quartiers)
```

#### d) Résidences secondaires

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Logement/nb_residences_secondaires.csv"

nb_res_secondaires <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r}
nb_res_secondaires <- nb_res_secondaires %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "nb_residences_secondaires" = "Nombre.de.résidences.secondaires.2020") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))

nb_res_secondaires$nb_residences_secondaires <- as.integer(nb_res_secondaires$nb_residences_secondaires)

head(nb_res_secondaires)
```


### I.2.C. Urbanisme


#### a) Programmes

Nous allons importer le fichier qui recense les villages d'avenir (communes qui sont bénéficiaires d'un programme : PVD, ACV, ...)

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/zonages.xlsx"

zonages_prog <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(zonages_prog)
```

On conserve les colonnes avec le code de la commune et si elle est bénéficiaire ou non d'un programme (ACV / PVD / ...)

```{r}
zonages_prog <- zonages_prog %>% 
  select(1,3) %>% 
  rename("beneficiaire_prog" = va_zpp) %>% 
  mutate(beneficiaire_prog = gsub("out", "0", beneficiaire_prog)) %>%
  mutate(beneficiaire_prog = gsub("in", "1", beneficiaire_prog))

head(zonages_prog)
```

On conserve les communes de Bretagne

```{r}
zonages_prog <- zonages_prog %>% 
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
zonages_prog <- zonages_prog %>% 
  rename(code_insee = codgeo)
```

#### b) CRTE

On importe ensuite les données concernant les communes couvertes par les CRTE 

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/liste-crte-com2023-20230823.csv"

liste_crte <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(liste_crte)
```

On ne conserve seulement que la colonne avec le code commune et on ajoute une colonne avec la valeur 1 pour signifier qu'elles sont couvertes par les CRTE (variable binaire)

```{r}
liste_crte <- liste_crte %>% 
  select(1) %>% 
  group_by(insee_com) %>% 
  mutate("couverte_crte" = 1)

head(liste_crte)
```

Nous allons seulement conserver les communes de Bretagne

```{r}
liste_crte <- liste_crte %>% 
  filter(substr(insee_com, 1, 2) %in% c("22", "29", "35", "56")) 
```

Nous avons une commune manquante que nous allons ajouter

```{r}
communes_crte <- merge(liste_crte, communes, 
                                  by.x = "insee_com",  by.y = "code_commune", 
                                  all = TRUE, suffix = c("_crte", "_com"))

# Mettre 0 pour les valeurs non renseignées
communes_crte$couverte_crte <- ifelse(is.na(communes_crte$couverte_crte), 0, 1)

communes_crte <- communes_crte %>% 
  select(insee_com, couverte_crte)

head(communes_crte)
```

```{r}
communes_crte <- communes_crte %>% 
  rename(code_insee = insee_com)
```

```{r}
# Suppression variables inutiles
rm(liste_crte)
```


#### c) Loi littoral (climat)

Nous allons à présent importer les données pour savoir si la commune est concernée par la loi littoral (COG de 2022)

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/loi_littoral-1996-COG2022.xlsx"

loi_littoral <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    sheet = "Perimetre",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(loi_littoral)
```

On conserve le code insee de la commune et le classement. On va ensuite convertir la variable classement en une variable à plusieurs modalités

```{r}
loi_littoral <- loi_littoral %>% 
  select(INSEE_COM, CLASSEMENT)

head(loi_littoral)
```

On transforme ensuite la variable CLASSEMENT en une variable à 3 modalités

```{r}
table(loi_littoral$CLASSEMENT)
```

Nous allons conserver les communes de Bretagne

```{r}
loi_littoral <- loi_littoral %>% 
  filter(substr(INSEE_COM, 1, 2) %in% c("22", "29", "35", "56")) 

table(loi_littoral$CLASSEMENT)
```

```{r}
loi_littoral <- loi_littoral %>% 
  mutate(CLASSEMENT = gsub("Estuaire", 1, CLASSEMENT)) %>%
  mutate(CLASSEMENT = gsub("Mer", 2, CLASSEMENT)) 

table(loi_littoral$CLASSEMENT)
```

On remarque que nous avons seulement 264 communes de Bretagne, nous allons donc devoir compléter cette variable.

```{r}
loi_littoral <- merge(loi_littoral, communes, 
                                  by.x = "INSEE_COM", by.y = "code_commune", 
                                  all = TRUE, suffix = c("_littoral", "_com"))

# Mettre 0 pour les valeurs non renseignées --> correspond à une commune non concernée par la loi littoral
loi_littoral$climat <- ifelse(is.na(loi_littoral$CLASSEMENT), 0, loi_littoral$CLASSEMENT)

loi_littoral <- loi_littoral %>% 
  select(INSEE_COM, climat) 

loi_littoral$climat <- factor(loi_littoral$climat)

head(loi_littoral)
```

```{r}
loi_littoral <- loi_littoral %>% 
  rename(code_insee = INSEE_COM)
```

#### d) Densité

Nous allons ensuite importer les données qui décrivent la grille communale de densité en 7 niveaux : 
- niveau 1 : Grands centres urbains
- niveau 2 : Centres urbains intermédiaires
- niveau 3 : Petites villes
- niveau 4 : Ceintures urbaines
- niveau 5 : Bourgs ruraux
- niveau 6 : Rural à habitat dispersé
- niveau 7 : Rural à habitat très dispersé

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/densite_7niveaux.xlsx"

densite7 <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    sheet = 'Data',
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(densite7)
```

On conserve le code et la grille de niveaux

```{r}
densite7 <- densite7 %>% 
  select(1,3)

head(densite7)
```

Nous allons conserver seulement les communes de Bretagne

```{r}
densite7 <- densite7 %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
densite7 <- densite7 %>% 
  rename(code_insee = codgeo)
```


#### e) Superficie

Nous allons ensuite importer les données concernant la superficie de chaque commune

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/superficie.xlsx"

superficie <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    sheet = 'Data',
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(superficie)
```


Nous allons conserver les superficies les plus actualisées (pour l'année 2020) et sélectionner les colonnes qui nous intéressent

```{r}
superficie <- superficie %>% 
  filter(an == 2020) %>% 
  select(codgeo, superf_choro)

head(superficie)
```

Nous allons sélectionner les données pour les communes de Bretagne

```{r}
superficie <- superficie %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56"))
```

```{r}
superficie <- superficie %>% 
  rename(code_insee = codgeo)
```

### I.2.D. Transport

Nous allons maintenant importer des données concernant la thématique du transport.

#### a) Gares

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Transport/arret_ferroviaire.csv"

gares <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(gares)
```

On conserve les colonnes qui peuvent nous être utiles par la suite

```{r}
gares <- gares %>% 
  select(code_uic,code_insee, tgv)
head(gares)
```

On modifie la variable pour avoir une variable binaire

```{r}
gares <- gares %>%  
  mutate(tgv = gsub("O", "1", tgv)) %>%
  mutate(tgv = gsub("N", "0", tgv)) 
```

Il faut supprimer les doublons => garder O si O et N sinon 0

```{r}
length(unique(gares$code_insee))
```

Nous allons seulement conserver les communes de Bretagne

```{r}
gares <- gares %>%
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56")) 
```

Pour avoir seulement une variable binaire, nous allons grouper par code insee et mettre la valeur 1 quand il y a un arrêt ferroviaire

```{r}
gares <- gares %>%
  group_by(code_insee) %>%
  summarize(tgv = 1)
```

Nous allons récupérer le reste des communes bretonnes

```{r}
gares <- merge(gares, communes,
               by.x = "code_insee",  by.y = "code_commune",
               all = TRUE, suffix = c("_gares", "_com"))

# Mettre 0 pour les valeurs non renseignées
gares$gare_tgv <- ifelse(is.na(gares$tgv), 0, 1)

# On ne conserve que les communes de Bretagne
gares <- gares %>%
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56")) 

gares <- gares %>% 
  select(code_insee, gare_tgv)

head(gares)
```

#### b) Déplacements domicile-travail

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Transport/part_deplacement_dom_travail.csv"

part_deplacement_dom_travail <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```


```{r}
part_deplacement_dom_travail <- part_deplacement_dom_travail %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "part_trajets_voiture" = "Part.des.déplacements.domicile.travail.en.voiture.2020") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))

part_deplacement_dom_travail$part_trajets_voiture <- as.numeric(part_deplacement_dom_travail$part_trajets_voiture)

head(part_deplacement_dom_travail)
```


### I.2.E. Population / Economie / Emploi

#### a) Revenu disponible

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/mediane_revenu_dispo.xlsx"

revenu_dispo <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(revenu_dispo)
```

On sélectionne les variables qui nous intéresse pour la suite

```{r}
revenu_dispo <- revenu_dispo %>% 
  select(codgeo, med_disp)
```

On ne conserve que les données de la région Bretagne

```{r}
revenu_dispo <- revenu_dispo %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
revenu_dispo <- revenu_dispo %>% 
  rename(code_insee = codgeo)
```

#### b) Population

Nous allons maintenant importer les données de population

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/population.xlsx"

pop <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(pop)
```

```{r}
pop <- pop %>% 
  filter(an == 2020) %>% 
  select(codgeo, p_pop)

head(pop)
```

Nous ne gardons que les communes de Bretagne

```{r}
pop <- pop %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
pop <- pop %>% 
  rename(code_insee = codgeo)
```

#### c) CSP du Maire

Nous allons maintenant importer des données un peu plus sensibles : les maires en 2023

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/elus-municipaux-cm.csv"

elus <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(elus)
```

On ne conserve que les lignes pour la région Bretagne

```{r}
elus <- elus %>% 
  filter(`Code.du.département` == "35" | `Code.du.département` == "22" |`Code.du.département` == "29" | `Code.du.département` == "56") %>% 
  filter( `Libellé.de.la.fonction` == "Maire") %>% 
  select(`Code.de.la.commune`, `Code.de.la.catégorie.socio.professionnelle`, `Libellé.de.la.catégorie.socio.professionnelle`, `Libellé.de.la.fonction`)
```

On ne garde que le code et le code de la CSP 

```{r}
elus <- elus %>% 
  select(1,2) %>% 
  rename(code_insee = `Code.de.la.commune`, 
         CSP_maire = `Code.de.la.catégorie.socio.professionnelle`)
```

On récupère les communes manquantes pour la région Bretagne

```{r}
elus <- merge(elus, communes,
               by.x = "code_insee",  by.y = "code_commune",
               all = TRUE, suffix = c("_elus", "_com"))

# Mettre NA pour les valeurs non renseignées
elus$CSP_maire <- ifelse(is.na(elus$CSP_maire), NA, elus$CSP_maire)

# On ne conserve que les communes de Bretagne
elus <- elus %>%
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56")) 

elus <- elus %>% 
  select(code_insee, CSP_maire)

head(elus)
```


#### d) Taux d'endettement 

Nous allons maintenant importer les données au sujet du taux d'endettement des communes

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/taux_endettement2022.csv"

taux_endettement <- 
  aws.s3::s3read_using(
    FUN = read.csv,sep = ";",
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(taux_endettement)
```
On ne garde que les colonnes qui nous intéresse et seulement pour la région Bretagne

```{r}
taux_endettement <- taux_endettement %>%
  select(1,4) %>% 
  rename("code_insee" = "codgeo") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))

head(taux_endettement)
```

```{r}
# Remplacement des valeurs -9999 par NA 
taux_endettement <- taux_endettement %>% 
  mutate(com_variation_encours_dette_ha_pct = ifelse(com_variation_encours_dette_ha_pct == -9999, NA, com_variation_encours_dette_ha_pct))
```



#### e) Inactifs

Nous allons importer le fichier qui contient le nombre d'inacyifs de 15 à 64 ans en 2020 selon les communes.

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/nb_inactifs_15-64ans.csv"

nb_inactifs <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(nb_inactifs)
```

```{r}
nb_inactifs <- nb_inactifs %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "nb_inactifs" = "Nombre.d.inactifs.de.15.64.ans.2020") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))
```


#### f) Actifs

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/nb_actifs_15-64ans.csv"

nb_actifs <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(nb_actifs)
```

```{r}
nb_actifs <- nb_actifs %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "nb_actifs" = "Nombre.d.actifs.de.15.64.ans.2020") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))
```

#### g) Dépendance économique

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/dependance_economique.csv"

dependance_eco <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r}
dependance_eco <- dependance_eco %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "dependance_eco" = "Indicateur.de.dépendance.économique.2020") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))


dependance_eco$dependance_eco <- as.numeric(dependance_eco$dependance_eco)

head(dependance_eco)
```

#### h) Taux d'abstention au premier tour des municipales

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/taux_abstention.csv"

taux_abstention <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r}
taux_abstention <- taux_abstention %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "abstention_municipales" = "Municipales...Taux.d.abstention.au.1er.tour.2020") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))


taux_abstention$abstention_municipales <- as.numeric(taux_abstention$abstention_municipales)

head(taux_abstention)
```

#### i) Taux de création d'entreprises

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/taux_creation_entreprises.csv"

taux_creation_entreprises <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r warning = FALSE}
taux_creation_entreprises <- taux_creation_entreprises %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "taux_creation_ent" = "Taux.de.création.d.entreprises.2021") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))


taux_creation_entreprises$taux_creation_ent <- as.numeric(taux_creation_entreprises$taux_creation_ent)

head(taux_creation_entreprises)
```
#### j) Nombre d'entreprises

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/nb_entreprises.csv"

nb_entreprises <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r warning = FALSE}
nb_entreprises <- nb_entreprises %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "total_entreprises" = "Nombre.d.entreprises.par.secteurs.d.activité.2021") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))


nb_entreprises$total_entreprises <- as.integer(nb_entreprises$total_entreprises)

head(nb_entreprises)
```

### I.2.F. Social

#### a) Licenciés sportifs

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Social/licencies_sportifs.csv"

sportifs_licencies <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r warning = FALSE}
sportifs_licencies <- sportifs_licencies %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "nb_licencies_sportifs" = "Nombre.de.licenciés.sportifs.2019") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))

sportifs_licencies$nb_licencies_sportifs <- as.integer(sportifs_licencies$nb_licencies_sportifs)

head(sportifs_licencies)
```


#### b) 20-24 ans sans diplôme

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Social/20-24ans_sans_diplome.csv"

jeunes_sans_diplome <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    sep= ";",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

```{r}
jeunes_sans_diplome <- jeunes_sans_diplome %>% 
  select(1,3) %>% 
  rename("code_insee" = "Code", 
         "part_jeunes_sans_diplome" = "Part.des.20.24.ans.sans.diplôme.2020") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))

jeunes_sans_diplome$part_jeunes_sans_diplome <- as.numeric(jeunes_sans_diplome$part_jeunes_sans_diplome)

head(jeunes_sans_diplome)
```


## I.3. Constitution de la base de données

### I.3.A. Rassemblement de toutes les données

Nous allons maintenant constituer notre base de données pour pouvoir avoir toutes les informations dans un seul et même dataframe

```{r}
liste_dataframes <- list(beneficiaires_prog_trans_eco, conso_agriculture, conso_industrie, conso_tertiaire, conso_residentiel, conso_totale, emissions_ges,
friches, communes_eco_quartiers, nb_res_secondaires, zonages_prog, loi_littoral, 
densite7,  superficie, gares, part_deplacement_dom_travail, 
revenu_dispo, pop, elus,taux_endettement, nb_inactifs, nb_actifs, dependance_eco, taux_abstention, taux_creation_entreprises, nb_entreprises,
sportifs_licencies, jeunes_sans_diplome)


df_final <- Reduce(function(x, y) merge(x, y, by = "code_insee", all = TRUE), liste_dataframes)

# Affichage du dataframe final
print(df_final)
```

On transforme les variables pour les avoir dans le bon format

```{r}
# Transformation en variable catégorielle (facteur)
df_final$ecoquartiers <- as.factor(df_final$ecoquartiers)
df_final$beneficiaire_prog <- as.factor(df_final$beneficiaire_prog)
df_final$gridens7 <- as.factor(df_final$gridens7)
df_final$gare_tgv <- as.factor(df_final$gare_tgv)
df_final$CSP_maire <- as.factor(df_final$CSP_maire)
df_final$beneficiaire_trans_eco <- as.factor(df_final$beneficiaire_trans_eco) # variable à expliquer


# Transformation en variable numérique
df_final$nb_inactifs <- as.integer(df_final$nb_inactifs)
df_final$nb_actifs <- as.integer(df_final$nb_actifs)
```

```{r}
rm(liste_dataframes)
```

On s'assure que nos données sous bien sous forme de dataframe

```{r}
df_final <- as.data.frame(df_final)
```


```{r}
head(df_final)
```


### I.3.B. Gestion des valeurs manquantes

Nous allons d'abord analyser si nous avons beaucoup de valeurs manquantes : 

```{r}
sum(is.na(df_final))
```

Nous allons afficher les lignes qui comportent des données manquantes : 

```{r}
which(is.na(df_final))
```

Suppression des données manquantes

```{r}
df_final <- df_final %>% 
  drop_na()
```



### I.3.C Mise à l'échelle des données

Pour avoir des données cohérentes, je vais réduire les colonnes qui présentent d'importants écarts et qui peuvent changer l'interprétation de notre modélisation

```{r}

```



# II. Export de la base de données finale

```{r}
FILE_KEY_OUT_S3 <- "Sujet_master/Data/BDD_finale/bdd_finale.csv"
BUCKET_OUT <- "marieguibert2"

aws.s3::s3write_using(
    df_final,
    FUN = readr::write_csv, 
    object = FILE_KEY_OUT_S3,
    bucket = BUCKET_OUT,
    opts = list("region" = "")
)
```


