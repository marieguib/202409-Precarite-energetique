---
title: "Quelles seront les sollicitations de subventions pour le fonds verts des communes en Bretagne ? Et pourquoi ?"
author: "Marie Guibert"
date: "2024-03-05"
output:
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
---

# Environnement de travail


```{r message = FALSE, warning = FALSE}
library(aws.s3)
library(dplyr)
library(stringr)
library(ggplot2)
library(VIM) # valeurs manquantes
library(FactoMineR)
library(Amelia) # analyse factorielle
library(mice)
library(missMDA)
```

# I. Importations et traitements des données

Tout d'abord, nous allons nous focaliser sur la région Bretagne dans un premier temps lors de cette étude. 

## I.1. Variable à expliquer

On importe d'abord les données CHORUS concernant le programme 380 (fonds vert) au niveau communal pour récupérer les informations nécessaires à notre étude. 

```{r message = FALSE}
BUCKET <- "marieguibert2"
FILE_KEY_S3 <- "Sujet_master/Data/Y/prog380_communes.csv"

ae_fonds_vert <- 
  aws.s3::s3read_using(
    FUN = readr::read_csv, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

ae_fonds_vert$beneficiaire_code <- as.character(ae_fonds_vert$beneficiaire_code)

head(ae_fonds_vert)
```

```{r}
dim(ae_fonds_vert)
```

Nous avons 232 bénéficiaires de ce programme et 68 colonnes. 
Nous allons vérifier que nos données ne contiennent bien que des communes :

```{r include=FALSE}
# Vérification qu'on ait que des communes
table(ae_fonds_vert$denomination)
```

```{r}
# Vérification que toutes les données soient sur 2023
table(ae_fonds_vert$annee)
```

Ce tableau nous montre que le programme du fonds vert ne contient des données seulement pour l'année 2023. 

### Montant des AE

Nous allons nous intéresser au code INSEE de la commune du SIRET et le montant du financement. 

*Ici, le "code_commune" correspond à la commune du SIRET (jointure réalisée précédemment dans SQL Lab)*

```{r}
ae_fonds_vert_montant <- ae_fonds_vert %>% 
  select(code_commune, montant_ae) %>% 
  group_by(code_commune) %>% 
  summarize(somme_ae = sum(montant_ae))

head(ae_fonds_vert_montant)
```

### Nombre de demandes de financements

Nous allons grouper par **commune du SIRET** pour avoir une approche communale et pour savoir le nombre de projets par commune.

```{r}
ae_fonds_vert_nb <- ae_fonds_vert %>%
  group_by(code_commune) %>%
  summarize(nb_projets = n())

head(ae_fonds_vert_nb)
```
```{r}
table(ae_fonds_vert_nb$nb_projets)
```

Puisque nous avons une grande majorité de communes demandant un seul financement, nous allons passer notre variable en binaire : "a demandé un financement / n'a pas demandé de financement".
- Valeur 1 : a demandé un financement
- Valeur 0 : n'a pas demandé de financement

Cette manipulation va nous simplifier le travail

```{r}
ae_fonds_vert_binaire <- ae_fonds_vert %>%
  select(code_commune) %>% 
  group_by(code_commune) %>%
  summarize(beneficiaire_prog380 = 1)


# Conversion pour avoir les mêmes types que dans le fichier communes
ae_fonds_vert_binaire$code_commune <- as.character(ae_fonds_vert_binaire$code_commune)

head(ae_fonds_vert_binaire)
```

Notre tableau final contient bien le code de la commune du SIRET et si la commune a demandé un financement (1)

### Fichier des communes

Pour pouvoir constituer notre variable à expliquer, il nous faut le reste des communes de Bretagne pour pouvoir savoir quelles communes n'ont pas fait de demande de financement

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/Y/v_commune_2023.csv"

communes <- 
  aws.s3::s3read_using(
    FUN = read.csv, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(communes)
```


On filtre d'abord sur la Bretagne pour n'avoir que les communes qui nous intéressent.

```{r}
communes <- communes %>% 
  select(COM, REG) %>% 
  filter(REG == 53) %>% 
  select(COM)
```

On ajoute une colonne avec la valeur 0

```{r}
communes <- communes %>% 
  mutate(beneficiaire_prog380 = 0) %>% 
  rename(code_commune = COM)
```

Nous allons maintenant assembler les deux fichiers pour avoir notre variable à expliquer complète.

### Constitution de la variable à expliquer (binaire)

Règle : si un code INSEE d'une commune apparaît avec la valeur 0 ET la valeur 1 alors on garde seulement la ligne avec la valeur 1 => cela signifie qu'elle a fait une demande de financement


```{r}
beneficiaires_fonds_vert <- merge(ae_fonds_vert_binaire, communes, 
                                  by = "code_commune", 
                                  all = TRUE, suffix = c("_ae", "_com"))

# Remplacer les valeurs NA par 0
beneficiaires_fonds_vert$beneficiaire_prog380 <- ifelse(is.na(beneficiaires_fonds_vert$beneficiaire_prog380_ae), 0, 1)

beneficiaires_fonds_vert <- beneficiaires_fonds_vert %>% 
  select(code_commune, beneficiaire_prog380)

head(beneficiaires_fonds_vert)
```

```{r}
dim(beneficiaires_fonds_vert)
```

Nous avons bien 1207 communes (nombre de communes en Bretagne)

```{r}
# Renommage de la colonne pour le code commune en code INSEE
beneficiaires_fonds_vert <- beneficiaires_fonds_vert %>% 
  rename(code_insee = code_commune)
```

### Distribution de notre variable à explqiuer

Nous allons analyser la distribution des 1 et 0 dans notre variable à expliquer

```{r}
ggplot(beneficiaires_fonds_vert)+
  aes(x = beneficiaire_prog380)+
  geom_bar(fill="lightblue")+
  ggtitle("Nombre de communes ayant demandé un financement pour le programme 380")
```
```{r}
table(beneficiaires_fonds_vert$beneficiaire_prog380)
```

Nous avons donc des données déséquilibrées à traiter de ce cas là.


```{r}
# Suppression des variables inutiles
rm(ae_fonds_vert)
rm(ae_fonds_vert_binaire)
rm(ae_fonds_vert_montant)
rm(ae_fonds_vert_nb)
```

## I.2. Variables explicatives

Nous allons à présent passer à l'importation des différentes variables explicatives. 


### I.2.A. Energie

Nous allons importer les données de consommation annuelle d'électricité et de gaz

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Energie/conso-elec-gaz-annuelle-par-secteur-dactivite-agregee-commune.csv"

conso_elec_gaz <- 
  aws.s3::s3read_using(
    FUN = read.csv, 
    sep = ";",
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )
```

Nous allons ensuite filtrer pour n'avoir que les lignes concernant la Bretagne

```{r}
conso_elec_gaz <- conso_elec_gaz %>% 
  filter(Code.Région == 53) %>% 
  filter(Opérateur == "Enedis")
```

Ensuite, nous allons faire la moyenne pour n'avoir qu'un seul chiffre par commune

```{r}
conso_agriculture <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`,`Consommation.Agriculture..MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_agri = mean(`Consommation.Agriculture..MWh.`))

conso_agriculture <- conso_agriculture %>% 
  rename(code_insee = Code.Commune)

head(conso_agriculture)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_agriculture <- merge(communes, conso_agriculture, by.x = "code_commune", by.y = "code_insee")
```

```{r}
conso_industrie <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.Industrie..MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_indus = mean(`Consommation.Industrie..MWh.`))

conso_industrie <- conso_industrie %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_industrie <- merge(communes, conso_industrie, by.x = "code_commune", by.y = "code_insee")
```

```{r}
conso_tertiaire <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`,`Consommation.Tertiaire...MWh.`) %>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_tertiaire = mean(`Consommation.Tertiaire...MWh.`))

conso_tertiaire <- conso_tertiaire %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_tertiaire <- merge(communes, conso_tertiaire, by.x = "code_commune", by.y = "code_insee")
```

```{r}
conso_residentiel <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.Résidentiel...MWh.`)%>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_residentiel = mean(`Consommation.Résidentiel...MWh.`))

conso_residentiel <- conso_residentiel %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_residentiel <- merge(communes, conso_residentiel, by.x = "code_commune", by.y = "code_insee")
```

```{r}
conso_totale <- conso_elec_gaz %>% 
  select(Année,`Code.Commune`, `Consommation.totale..MWh.`)%>% 
  group_by(`Code.Commune`) %>%
  summarize(moyenne_conso_totale = mean(`Consommation.totale..MWh.`))


conso_totale <- conso_totale %>% 
  rename(code_insee = Code.Commune)
```

On a 1208 lignes alors qu'on a seulement 1207 communes dans notre référentiel, on va donc ne retenir que les lignes nous concernant

```{r}
conso_totale <- merge(communes, conso_totale, by.x = "code_commune", by.y = "code_insee")
```

Nous allons vérifier s'il y a des valeurs manquantes

```{r}
sum(is.na(conso_agriculture))
sum(is.na(conso_industrie))
sum(is.na(conso_residentiel))
sum(is.na(conso_tertiaire))
sum(is.na(conso_totale))
```

Nous n'avons pas de données manquantes


```{r}
# On supprime la variable qui ne nous sert pas 
rm(conso_elec_gaz)
```


### I.2.B. Logement

Nous allons importer des données concernant la thématique du logement

#### a) DPE

Tout d'abord, nous allons nous focaliser sur le DPE des logements. Le Diagnostic de Performance Energétique (DPE) renseigne sur la performance énergétique et environnementale d’un logement ou d’un bâtiment, en évaluant sa consommation d’énergie et son impact en matière d’émissions de gaz à effet de serre.


```{r}

```

#### b) Friches

Nous allons maintenant nous intéresser à la base de données "cartofriches". Elle permet de référencer des sites potentiellement en friche. Le terme de « friches » est pris ici dans le sens d’espaces artificialisés et inoccupés.

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Logement/friches-standard.csv"

friches <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

friches <- friches %>% 
  select(comm_insee) %>% 
  group_by(comm_insee) %>% 
  summarize(nb_friches = n())
  
  
head(friches)
```
Pour avoir le reste des communes de la France, nous allons ajouter des 0 sur les lignes où on a pas de valeur

```{r}
friches <- merge(friches, communes, 
                                  by.x = "comm_insee", by.y = "code_commune",
                                  all = TRUE, suffix = c("_friche", "_com"))

# On ne garde que les communes en Bretagne
friches <- friches %>%
  filter(substr(comm_insee, 1, 2) %in% c("22", "29", "35", "56")) 

# Si le nombre de friches est NA alors on remplace par 0
friches$friche <- ifelse(is.na(friches$nb_friches), 0, friches$nb_friches)

friches <- friches %>% 
  select(comm_insee, friche)

head(friches)
```

```{r}
# Renommage de la colonne pour le code insee
friches <- friches %>% 
  rename(code_insee = comm_insee)
```

#### c) Ecoquartiers

La démarche ÉcoQuartier, portée par le Ministère de la Transition écologique et de la Cohésion des Territoires, favorise de nouvelles façons de concevoir, construire et gérer la ville durablement. 
Cette variable m'a donc paru importante à inclure dans le programme du fonds vert. 

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Logement/EcoQuartiers_jan2016.csv"

eco_quartiers <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(eco_quartiers)  
```

On conserve seulement la colonnes qui nous intéresse pour notre étude : le code INSEE. On considère que si la commune apparaît, alors elle porte / fait partie d'un projet d'écoquartiers. 

```{r}
eco_quartiers <- eco_quartiers %>% 
  select(`Code INSEE`) %>% 
  group_by(`Code INSEE`) %>% 
  mutate(ecoquartiers= n())

head(eco_quartiers)
```

Nous allons ajouter les communes ne présentant pas d'écoquartiers 

```{r}
communes_eco_quartiers <- merge(eco_quartiers, communes, 
                                  by.x = "Code INSEE", by.y = "code_commune", 
                                  all.y = TRUE, suffix = c("_ecoquartiers", "_com"))

# Remplacer les valeurs NA par 0
communes_eco_quartiers$beneficiaire <- ifelse(is.na(communes_eco_quartiers$ecoquartiers), 0, 1)

communes_eco_quartiers <- communes_eco_quartiers %>% 
  select(`Code INSEE`, beneficiaire) %>% 
  rename(ecoquartiers = beneficiaire)

head(communes_eco_quartiers)
```

On ne conserve que les communes de Bretagne

```{r}
communes_eco_quartiers <- communes_eco_quartiers %>% 
  filter(substr(`Code INSEE`, 1, 2) %in% c("22", "29", "35", "56")) 
```

On va supprimer les doublons : on considère cette variable comme une variable binaire donc on ne comptabilise pas le nombre d'éco-quartiers

```{r}
communes_eco_quartiers <- distinct(communes_eco_quartiers)
```

```{r}
communes_eco_quartiers <- communes_eco_quartiers %>% 
  rename(code_insee = `Code INSEE`)
```

```{r}
# Suppression variables inutiles
rm(eco_quartiers)
```

### I.2.C. Urbanisme


#### a) Programmes

Nous allons importer le fichier qui recense les villages d'avenir (communes qui sont bénéficiaires d'un programme : PVD, ACV, ...)

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/zonages.xlsx"

zonages_prog <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(zonages_prog)
```

On conserve les colonnes avec le code de la commune et si elle est bénéficiaire ou non d'un programme (ACV / PVD / ...)

```{r}
zonages_prog <- zonages_prog %>% 
  select(1,3) %>% 
  rename("beneficiaire_prog" = va_zpp) %>% 
  mutate(beneficiaire_prog = gsub("out", "0", beneficiaire_prog)) %>%
  mutate(beneficiaire_prog = gsub("in", "1", beneficiaire_prog))

head(zonages_prog)
```

On conserve les communes de Bretagne

```{r}
zonages_prog <- zonages_prog %>% 
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
zonages_prog <- zonages_prog %>% 
  rename(code_insee = codgeo)
```

#### b) CRTE

On importe ensuite les données concernant les communes couvertes par les CRTE 

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/liste-crte-com2023-20230823.csv"

liste_crte <- 
  aws.s3::s3read_using(
    FUN = readr::read_delim,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(liste_crte)
```

On ne conserve seulement que la colonne avec le code commune et on ajoute une colonne avec la valeur 1 pour signifier qu'elles sont couvertes par les CRTE (variable binaire)

```{r}
liste_crte <- liste_crte %>% 
  select(1) %>% 
  group_by(insee_com) %>% 
  mutate("couverte_crte" = 1)

head(liste_crte)
```

Nous allons seulement conserver les communes de Bretagne

```{r}
liste_crte <- liste_crte %>% 
  filter(substr(insee_com, 1, 2) %in% c("22", "29", "35", "56")) 
```

Nous avons une commune manquante que nous allons ajouter

```{r}
communes_crte <- merge(liste_crte, communes, 
                                  by.x = "insee_com",  by.y = "code_commune", 
                                  all = TRUE, suffix = c("_crte", "_com"))

# Mettre 0 pour les valeurs non renseignées
communes_crte$couverte_crte <- ifelse(is.na(communes_crte$couverte_crte), 0, 1)

communes_crte <- communes_crte %>% 
  select(insee_com, couverte_crte)

head(communes_crte)
```

```{r}
communes_crte <- communes_crte %>% 
  rename(code_insee = insee_com)
```

```{r}
# Suppression variables inutiles
rm(liste_crte)
```


#### c) Loi littoral (climat)

Nous allons à présent importer les données pour savoir si la commune est concernée par la loi littoral (COG de 2022)

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/loi_littoral-1996-COG2022.xlsx"

loi_littoral <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    sheet = "Perimetre",
    skip = 2,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(loi_littoral)
```

On conserve le code insee de la commune et le classement. On va ensuite convertir la variable classement en une variable à plusieurs modalités

```{r}
loi_littoral <- loi_littoral %>% 
  select(INSEE_COM, CLASSEMENT)

head(loi_littoral)
```

On transforme ensuite la variable CLASSEMENT en une variable à 3 modalités

```{r}
table(loi_littoral$CLASSEMENT)
```

```{r}
loi_littoral <- loi_littoral %>% 
  mutate(CLASSEMENT = gsub("Estuaire", 1, CLASSEMENT)) %>%
  mutate(CLASSEMENT = gsub("Lac", 2, CLASSEMENT)) %>% 
  mutate(CLASSEMENT = gsub("Mer", 3, CLASSEMENT))

table(loi_littoral$CLASSEMENT)
```

Nous allons conserver les communes de Bretagne

```{r}
loi_littoral <- loi_littoral %>% 
  filter(substr(INSEE_COM, 1, 2) %in% c("22", "29", "35", "56")) 

dim(loi_littoral)
```

On remarque que nous avons seulement 264 communes de Bretagne, nous allons donc devoir compléter cette variable.

```{r}
loi_littoral <- merge(loi_littoral, communes, 
                                  by.x = "INSEE_COM", by.y = "code_commune", 
                                  all = TRUE, suffix = c("_littoral", "_com"))

# Mettre 0 pour les valeurs non renseignées --> correspond à une commune non concernée par la loi littoral
loi_littoral$climat <- ifelse(is.na(loi_littoral$CLASSEMENT), 0, loi_littoral$CLASSEMENT)

loi_littoral <- loi_littoral %>% 
  select(INSEE_COM, climat) 

loi_littoral$climat <- factor(loi_littoral$climat)

head(loi_littoral)
```

```{r}
loi_littoral <- loi_littoral %>% 
  rename(code_insee = INSEE_COM)
```

#### d) Densité

Nous allons ensuite importer les données qui décrivent la grille communale de densité en 7 niveaux : 
- niveau 1 : Grands centres urbains
- niveau 2 : Centres urbains intermédiaires
- niveau 3 : Petites villes
- niveau 4 : Ceintures urbaines
- niveau 5 : Bourgs ruraux
- niveau 6 : Rural à habitat dispersé
- niveau 7 : Rural à habitat très dispersé

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/densite_7niveaux.xlsx"

densite7 <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    sheet = 'Data',
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(densite7)
```

On conserve le code et la grille de niveaux

```{r}
densite7 <- densite7 %>% 
  select(1,3)

head(densite7)
```

Nous allons conserver seulement les communes de Bretagne

```{r}
densite7 <- densite7 %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
densite7 <- densite7 %>% 
  rename(code_insee = codgeo)
```


#### e) Superficie

Nous allons ensuite importer les données concernant la superficie de chaque commune

```{r message = FALSE}
FILE_KEY_S3 <- "Sujet_master/Data/X/Urbanisme/superficie.xlsx"

superficie <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4, 
    sheet = 'Data',
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(superficie)
```


Nous allons conserver les superficies les plus actualisées (pour l'année 2020) et sélectionner les colonnes qui nous intéressent

```{r}
superficie <- superficie %>% 
  filter(an == 2020) %>% 
  select(codgeo, superf_choro)

head(superficie)
```

Nous allons sélectionner les données pour les communes de Bretagne

```{r}
superficie <- superficie %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56"))
```

```{r}
superficie <- superficie %>% 
  rename(code_insee = codgeo)
```

### I.2.D. Transport

Nous allons maintenant importer des données concernant la thématique du transport.

#### a) Gares

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Transport/arret_ferroviaire.csv"

gares <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(gares)
```

On conserve les colonnes qui peuvent nous être utiles par la suite

```{r}
gares <- gares %>% 
  select(code_uic,code_insee, tgv)
head(gares)
```

On modifie la variable pour avoir une variable binaire

```{r}
gares <- gares %>%  
  mutate(tgv = gsub("O", "1", tgv)) %>%
  mutate(tgv = gsub("N", "0", tgv)) 
```

Il faut supprimer les doublons => garder O si O et N sinon 0

```{r}
length(unique(gares$code_insee))
```

Nous allons seulement conserver les communes de Bretagne

```{r}
gares <- gares %>%
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56")) 
```

Pour avoir seulement une variable binaire, nous allons grouper par code insee et mettre la valeur 1 quand il y a un arrêt ferroviaire

```{r}
gares <- gares %>%
  group_by(code_insee) %>%
  summarize(tgv = 1)
```

Nous allons récupérer le reste des communes bretonnes

```{r}
gares <- merge(gares, communes,
               by.x = "code_insee",  by.y = "code_commune",
               all = TRUE, suffix = c("_gares", "_com"))

# Mettre 0 pour les valeurs non renseignées
gares$gare_tgv <- ifelse(is.na(gares$tgv), 0, 1)

# On ne conserve que les communes de Bretagne
gares <- gares %>%
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56")) 

gares <- gares %>% 
  select(code_insee, gare_tgv)

head(gares)
```


### I.2.E. Population / Economie / Emploi

#### a) Revenu disponible

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/mediane_revenu_dispo.xlsx"

revenu_dispo <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(revenu_dispo)
```

On sélectionne les variables qui nous intéresse pour la suite

```{r}
revenu_dispo <- revenu_dispo %>% 
  select(codgeo, med_disp)
```

On ne conserve que les données de la région Bretagne

```{r}
revenu_dispo <- revenu_dispo %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
revenu_dispo <- revenu_dispo %>% 
  rename(code_insee = codgeo)
```

#### b) Population

Nous allons maintenant importer les données de population

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/population.xlsx"

pop <- 
  aws.s3::s3read_using(
    FUN = readxl::read_excel,
    skip = 4,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(pop)
```

```{r}
pop <- pop %>% 
  filter(an == 2020) %>% 
  select(codgeo, p_pop)

head(pop)
```

Nous ne gardons que les communes de Bretagne

```{r}
pop <- pop %>%
  filter(substr(codgeo, 1, 2) %in% c("22", "29", "35", "56")) 
```

```{r}
pop <- pop %>% 
  rename(code_insee = codgeo)
```

#### c) CSP du Maire

Nous allons maintenant importer des données un peu plus sensibles : les maires en 2023

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/elus-municipaux-cm.csv"

elus <- 
  aws.s3::s3read_using(
    FUN = read.csv,
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(elus)
```

On ne conserve que les lignes pour la région Bretagne

```{r}
elus <- elus %>% 
  filter(`Code.du.département` == "35" | `Code.du.département` == "22" |`Code.du.département` == "29" | `Code.du.département` == "56") %>% 
  filter( `Libellé.de.la.fonction` == "Maire") %>% 
  select(`Code.de.la.commune`, `Code.de.la.catégorie.socio.professionnelle`, `Libellé.de.la.catégorie.socio.professionnelle`, `Libellé.de.la.fonction`)
```

On ne garde que le code et le code de la CSP 

```{r}
elus <- elus %>% 
  select(1,2) %>% 
  rename(code_insee = `Code.de.la.commune`, 
         CSP_maire = `Code.de.la.catégorie.socio.professionnelle`)
```

On récupère les communes manquantes pour la région Bretagne

```{r}
elus <- merge(elus, communes,
               by.x = "code_insee",  by.y = "code_commune",
               all = TRUE, suffix = c("_elus", "_com"))

# Mettre NA pour les valeurs non renseignées
elus$CSP_maire <- ifelse(is.na(elus$CSP_maire), NA, elus$CSP_maire)

# On ne conserve que les communes de Bretagne
elus <- elus %>%
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56")) 

elus <- elus %>% 
  select(code_insee, CSP_maire)

head(elus)
```


#### d) Taux d'endettement 

Nous allons maintenant importer les données au sujet du taux d'endettement des communes

```{r}
FILE_KEY_S3 <- "Sujet_master/Data/X/Economie_Emploi/taux_endettement2022.csv"

taux_endettement <- 
  aws.s3::s3read_using(
    FUN = read.csv,sep = ";",
    object = FILE_KEY_S3,
    bucket = BUCKET,
    opts = list("region" = "")
  )

head(taux_endettement)
```
On ne garde que les colonnes qui nous intéresse et seulement pour la région Bretagne

```{r}
taux_endettement <- taux_endettement %>%
  select(1,4) %>% 
  rename("code_insee" = "codgeo") %>% 
  filter(substr(code_insee, 1, 2) %in% c("22", "29", "35", "56"))

head(taux_endettement)
```

#### e) 

## I.3. Constitution de la base de données

Nous allons maintenant constituer notre base de données pour pouvoir avoir toutes les informations dans un seul et même dataframe

```{r}
liste_dataframes <- list(conso_agriculture, conso_industrie, conso_tertiaire, conso_residentiel, conso_totale, 
friches, communes_eco_quartiers, zonages_prog, communes_crte, loi_littoral, 
densite7,  superficie, gares, revenu_dispo, pop, elus)


df_final <- Reduce(function(x, y) merge(x, y, by = "code_insee", all = TRUE), liste_dataframes)

# Affichage du dataframe final
print(df_final)

```

## I.4. Gestion des valeurs manquantes

Nous allons d'abord séparer la variable à expliquer et la variable explicative de notre jeu de données

```{r}
prog380 <- df_final[,1] # variable à expliquer
don <- df_final[,2:17] # variable explicative
```

```{r}
don$climat <- as.numeric(don$climat)
don$gridens7 <- as.numeric(don$gridens7)
don$beneficiaire_prog_zonages <- as.numeric(don$beneficiaire_prog_zonages)
```


### I.4.1. Visualisation

Premièrement, nous allons visualiser les données manquantes pour essayer de savoir s'il y a une structure. Pour cela, nous allons construire un graphique qui présente la répartition des valeurs manquantes pour chaque variable de nos données

```{r}
aggr(don,only.miss=TRUE,sortVar=TRUE)
```
La variable climat présente un grand nombre de valeurs manquantes par rapport aux autres variables

Résumé des combinaisons de données manquantes :

```{r}
res <- summary(aggr(don,prop=TRUE,combined=TRUE))$combinations
res[rev(order(res[,2])),]
```

Aide :
Cette séquence de commandes génère un résumé des combinaisons de données manquantes dans l'ensemble de données don. Elle calcule d'abord le résumé en utilisant aggr() avec les options prop=TRUE (pour afficher les pourcentages) et combined=TRUE (pour combiner les résultats pour toutes les variables). Ensuite, elle trie les résultats en fonction du pourcentage de données manquantes dans l'ordre décroissant.


```{r}
# A revoir : pas très bien compris
matrixplot(don)
marginplot(don[,c("climat","CSP_maire")])
```
Création d'un ensemble de données catégorielles avec des indicateurs 'o' pour observé et 'm' pour manquant :

```{r}
mis.ind <- matrix("o", nrow=nrow(don), ncol=ncol(don))
mis.ind[is.na(don)] <- "m"
dimnames(mis.ind) <- dimnames(don)
```

Analyse de correspondance multiple (MCA) sur l'ensemble de données mis.ind pour visualiser l'association entre les variables catégorielles 'o' et 'm'.

```{r}
options(ggrepel.max.overlaps = Inf)
resMCA <- MCA(mis.ind)
plot(resMCA, invis="ind", title="Analyse de correspondance multiple pour visualiser l'association entre les variables catégorielle", max.overlaps = 9500)
```


### I.4.2. Gestion des valeurs manquantes


```{r}
# Imputation avec amelia
res.amelia <- amelia(don,m=100,p2s=0)
```

```{r}
# Imputation avec mice
res.mice <- mice(don,m=100,defaultMethod="norm", printFlag=F) # here the variability of the regression parameters is obtained by bootstrap
```

```{r}
# Imputation avec missMDA
res.MIPCA <- MIPCA(don,ncp=2)
```



```{r}
## Checking and visualization of the imputations 
plot(res.amelia)
par(mfrow=c(1,1))
compare.density(res.amelia, var="T12")
overimpute(res.amelia, var="maxO3")
# visualization with PCA 
plot(res.MIPCA,choice= "ind.supp"); plot(res.MIPCA,choice="var")
```

```{r}
## Pooling the results 
lm.mice.out <- with(res.mice, lm(maxO3 ~ T9+T12+T15+Ne9+Ne12+Ne15+Vx9+Vx12+Vx15+maxO3v))
pool.mice <- pool(lm.mice.out)
resultmice <- summary(pool.mice)

require(mice)
imp<-prelim(res.mi=res.MIPCA,X=ozone[,1:11])
fit <- with(data=imp,exp=lm(maxO3~T9+T12+T15+Ne9+Ne12+Ne15+Vx9+Vx12+Vx15+maxO3v))
res.pool<-pool(fit)
summary(res.pool)
```



# II. Visualisation des données


 ```{r}
# ggplot(superficie)+
#   aes(x = 1:34945, y = superf_choro)+
#   geom_point()
```



# III. Modélisation statistique






## III.1. Apprentissage supervisé

## III.2.Apprentissage non-supervisé


# IV. Résultats
